# useDeferredValue

**목차**

- [레퍼런스](#레퍼런스)
  - [주의사항](#주의사항)
- [useDeferredValue](#usedeferredvalue)
  - [사용법](#사용법)
  - [값을 지연시키는 것은 내부적으로 어떻게 작동하나요?](#값을-지연시키는-것은-내부적으로-어떻게-작동하나요)
  - [UI 일부에 대해 리렌더링 지연하기](#ui-일부에-대해-리렌더링-지연하기)
  - [콘텐츠가 오래되었음을 표시하기](#콘텐츠가-오래되었음을-표시하기)
  - [새 콘텐츠가 로딩되는 동안 오래된 콘텐츠 표시하기](#새-콘텐츠가-로딩되는-동안-오래된-콘텐츠-표시하기)

## 레퍼런스

### 주의사항

1. > useDeferredValue로 인한 백그라운드 리렌더링은 화면에 커밋될 때까지 Effects를 실행하지 않습니다.
   - 음 원래 화면에 커밋될 때까지 Effect가 실행되지 않는 거 아니었나요? 😅 벌써 헷갈리는 걸 보니 Effect 문서를 다시 봐야 겠네요.
   - useDefferedValue 사용시에는 예외적으로 커밋 순서가 변경이 된다는 내용인 것 같아요!

## 사용법

### 새 콘텐츠가 로딩되는 동안 오래된 콘텐츠 표시하기

1. > query는 즉시 업데이트되므로 input에 새 값이 표시됩니다. 그러나 deferredQuery는 데이터가 로딩될 때까지 이전 값을 유지하므로 SearchResults는 잠시 동안 오래된 결과를 표시합니다.
   - 예제 보니까 디바운스를 대체하는 것 같은데 Suspense를 사용할 때 React 내부에서 딜레이를 관리할 수 있도록 더 밀접하게 돕는 게 차이인 것 같아요.

### 콘텐츠가 오래되었음을 표시하기

- 확실히 지연된 값을 활용해서 업데이트되는 걸 보여주는 게 매번 로딩화면을 보여주는 것보다 사용자의 시각적 피로도가 덜한 것 같습니다. 다만 이런 기능들이 있어도 기획단계에서 포함되지 않으면 보여줄 수 없다는 게 아쉬울 때가 있어요

### 값을 지연시키는 것은 내부적으로 어떻게 작동하나요?

1. > 여기서 지연되는 것은 네트워크 요청 자체가 아니라 결과가 준비될 때까지 결과를 표시하는 것입니다.
   - 네트워크 요청 자체에는 영향을 전혀 미치지 않고, 해당 값을 화면에 표시하는 것에만 영향을 미치므로 performance 훅으로 분류되는 것 같네요
2. > 사용자가 계속 입력하더라도 각 키 입력에 대한 응답은 캐시 되므로 백스페이스를 누르면 즉시 다시 가져오지 않습니다.
   - 이 부분 번역이 좀 모호한 것 같아요. 백스페이스를 누르면 캐시된 결과가 즉시(instant) 보이고 다시 가져오지(fetch) 않습니다.

### UI 일부에 대해 리렌더링 지연하기

1. > 하지만 키 입력을 차단하지 않도록 목록 리렌더링의 우선순위를 낮출 수 있다는 것을 React에 알려줍니다. 목록은 입력보다 “지연”되었다가 “따라잡을” 것입니다.
   - 리렌더링의 우선순위를 조정하여 화면의 사용자 입력 경험을 더 좋게 만들 수 있다. 로군요. 이 글이 이야기하는 케이스가 하단의 예시 코드인 것 같은데, 동일한 경우 이슈를 해결할 수 있는 다른 방법도 있지만 (디바운스라던가..) 화면의 FID를 향상시킨다는 차원에서는 충분히 의미있는 hook인 것 같아요!

### 값을 지연하는 것은 디바운싱 및 스로틀링과 어떤 점이 다른가요?

- 상단 예시 보고 이 생각 했는데 바로 알려주네요😄 생각 읽힌 기분..

1. > 디바운싱이나 스로틀링과 달리 고정된 지연을 선택할 필요가 없습니다. 사용자의 디바이스가 빠른 경우(예: 고성능 노트북) 지연된 리렌더링은 거의 즉시 발생하며 눈에 띄지 않습니다. 사용자의 디바이스가 느린 경우, 기기 속도에 비례하여 목록이 input에 ‘지연’됩니다.

- 디바운싱과 다른 게 뭘까 궁금했는데 궁금증이 확실히 해결되었어요!

2. > 최적화하려는 작업이 렌더링 중에 발생하지 않는 경우에도 디바운싱과 스로틀링은 여전히 유용합니다. 예를 들어 디바운싱과 스로틀링을 사용하면 네트워크 요청을 더 적게 처리할 수 있습니다.
   - react의 렌더링 과정에서 지연이 필요하다면 useDeferredValue를 쓰는게 안정적이군요..!
